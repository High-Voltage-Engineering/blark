// IEC61131-3 Lark grammar based on X-Pie Software GmbH's original (v1.2)
// Distributed under the GPL as part of iec2xml.

start: iec_source

// Global settings

PRAGMA: /(?s){[^}]*?}/ ";"?
MULTI_LINE_COMMENT: /\(\*.*?\*\)/s
SINGLE_LINE_COMMENT: /\s*/ "//" /[^\n]/*

%import common.WS

%ignore WS
%ignore MULTI_LINE_COMMENT
%ignore SINGLE_LINE_COMMENT
%ignore PRAGMA

// B.0
iec_source: ( _library_element_declaration | action )*

_library_element_declaration: data_type_declaration
                            | function_declaration
                            | function_block_declaration
                            | program_declaration
                            | configuration_declaration
                            | global_var_declarations

// B.1.1
IDENTIFIER: /\w+/

// B.1.2
constant: time_literal
        | numeric_literal
        | STRING_LITERAL     -> string_literal
        | bit_string_literal
        | boolean_literal

// B.1.2.1
BIT_STRING: /(1|0)(_?(1|0))*/
OCTAL_STRING: /[0-7](_?[0-7])*/
HEX_STRING: /[0-9A-F](_?[0-9A-F])*/

INTEGER: /[0-9](_?[0-9])*/
SIGNED_INTEGER: ("+" | "-") INTEGER
FIXED_POINT: INTEGER "." INTEGER

EXPONENT: "E"i /(\+|\-)?[0-9](_?[0-9])*/

?numeric_literal: real_literal
                | integer_literal

integer_literal: INTEGER_TYPE_NAME "#" any_integer -> typed_integer_literal
               | any_integer                       -> untyped_integer_literal

?any_integer: "2#" BIT_STRING             -> binary_integer
            | "8#" OCTAL_STRING           -> octal_integer
            | "16#" HEX_STRING            -> hex_integer
            | SIGNED_INTEGER              -> signed_integer

real_literal: [ REAL_TYPE_NAME "#" ] /((\+|\-)?[0-9](_?[0-9])*)\.([0-9](_?[0-9])*)((e|E)(\+|\-)?([0-9](_?[0-9])*))?/
            | [ REAL_TYPE_NAME "#" ] /((\+|\-)?[0-9](_?[0-9])*)((e|E)(\+|\-)?([0-9](_?[0-9])*))/

bit_string_literal: [ BIT_STRING_TYPE_NAME "#" ] "2#" BIT_STRING    -> binary_bit_string_literal
                  | [ BIT_STRING_TYPE_NAME "#" ] "8#" OCTAL_STRING  -> octal_bit_string_literal
                  | [ BIT_STRING_TYPE_NAME "#" ] "16#" HEX_STRING   -> hex_bit_string_literal
                  | [ BIT_STRING_TYPE_NAME "#" ] INTEGER

boolean_literal: ( "BOOL#"i )? ( "1" | "TRUE"i )   -> true
               | ( "BOOL#"i )? ( "0" | "FALSE"i )  -> false

// B.1.2.2
STRING_LITERAL: SINGLE_BYTE_CHARACTER_STRING
              | DOUBLE_BYTE_CHARACTER_STRING

ESCAPE_CHARACTER: "$$"
                | "$L"
                | "$N"
                | "$P"
                | "$R"
                | "$T"
                | "$l"
                | "$n"
                | "$p"
                | "$r"
                | "$t"

SINGLE_BYTE_CHARACTER: /[^$']/
                     | ESCAPE_CHARACTER
                     | "$'"
                     | "$" /[0-9A-F][0-9A-F]/

DOUBLE_BYTE_CHARACTER: /[^$"]/
                     | ESCAPE_CHARACTER
                     | "$'"
                     | "$" /[0-9A-F][0-9A-F][0-9A-F][0-9A-F]/

SINGLE_BYTE_CHARACTER_STRING: "'" SINGLE_BYTE_CHARACTER* "'"
DOUBLE_BYTE_CHARACTER_STRING: "\"" DOUBLE_BYTE_CHARACTER* "\""

// B.1.2.3
time_literal: duration
            | time_of_day
            | date
            | date_and_time

// B.1.2.3.1
duration: ( "TIME"i | "T"i ) "#" "-"? _interval

_interval: days
         | hours
         | minutes
         | seconds
         | milliseconds

days: FIXED_POINT "d"i
    | INTEGER "d"i "_"? hours
    | INTEGER "d"i

hours: FIXED_POINT "h"i
     | INTEGER "h"i "_"? minutes
     | INTEGER "h"i

minutes: FIXED_POINT "m"i
       | INTEGER "m"i "_"? seconds
       | INTEGER "m"i

seconds: FIXED_POINT "s"i
       | INTEGER "s"i "_"? milliseconds
       | INTEGER "s"i

milliseconds: FIXED_POINT "ms"i
            | INTEGER "ms"i

// B.1.2.3.2
_daytime: day_hour ":" day_minute ":" day_second

time_of_day: ( "TIME_OF_DAY"i | "TOD"i ) "#" _daytime

day_hour: INTEGER
day_minute: INTEGER
day_second: FIXED_POINT

date: ( "DATE"i | "D"i | "d"i ) "#" date_literal

date_literal: year "-" month "-" day

year: INTEGER
month: INTEGER
day: INTEGER

date_and_time: ( "DATE_AND_TIME"i | "DT"i ) "#" date_literal "-" _daytime

// B.1.3
data_type_name: non_generic_type_name
              | GENERIC_TYPE_NAME

non_generic_type_name: [ POINTER_TO ] ( ELEMENTARY_TYPE_NAME | DERIVED_TYPE_NAME )

// B.1.3.1
TYPE_SINT: "SINT"i
TYPE_INT: "INT"i
TYPE_DINT: "DINT"i
TYPE_LINT: "LINT"i

TYPE_USINT: "USINT"i
TYPE_UINT: "UINT"i
TYPE_UDINT: "UDINT"i
TYPE_ULINT: "ULINT"i

TYPE_REAL: "REAL"i
TYPE_LREAL: "LREAL"i

TYPE_DATE: "DATE"i
TYPE_TIME: "TIME"i
TYPE_TOD: "TIME_OF_DAY"i
        | "TOD"i
TYPE_DATETIME: "DATE_AND_TIME"i
             | "DT"i

TYPE_BOOL: "BOOL"i
TYPE_BYTE: "BYTE"i
TYPE_WORD: "WORD"i
TYPE_DWORD: "DWORD"i
TYPE_LWORD: "LWORD"i

ELEMENTARY_TYPE_NAME: _NUMERIC_TYPE_NAME
                    | DATE_TYPE_NAME
                    | BIT_STRING_TYPE_NAME
                    | STRING_VAR_TYPE

_NUMERIC_TYPE_NAME: INTEGER_TYPE_NAME
                  | REAL_TYPE_NAME

INTEGER_TYPE_NAME: _SIGNED_INTEGER_TYPE_NAME
                 | _UNSIGNED_INTEGER_TYPE_NAME

_SIGNED_INTEGER_TYPE_NAME: TYPE_SINT
                         | TYPE_INT
                         | TYPE_DINT
                         | TYPE_LINT

_UNSIGNED_INTEGER_TYPE_NAME: TYPE_USINT
                           | TYPE_UINT
                           | TYPE_UDINT
                           | TYPE_ULINT
REAL_TYPE_NAME: TYPE_REAL
              | TYPE_LREAL

DATE_TYPE_NAME: TYPE_TOD
              | TYPE_DATETIME
              | TYPE_DATE
              | TYPE_TIME

BIT_STRING_TYPE_NAME: TYPE_BOOL
                    | TYPE_BYTE
                    | TYPE_WORD
                    | TYPE_DWORD
                    | TYPE_LWORD

// B.1.3.2
GENERIC_TYPE_NAME: "ANY"
                 | "ANY_DERIVED"
                 | "ANY_ELEMENTARY"
                 | "ANY_MAGNITUDE"
                 | "ANY_NUM"
                 | "ANY_REAL"
                 | "ANY_INT"
                 | "ANY_BIT"
                 | "ANY_STRING"
                 | "ANY_DATE"

// B.1.3.3
SIMPLE_TYPE_NAME: IDENTIFIER
SUBRANGE_TYPE_NAME: IDENTIFIER
ENUMERATED_TYPE_NAME: IDENTIFIER
ARRAY_TYPE_NAME: IDENTIFIER
STRUCTURE_TYPE_NAME: IDENTIFIER
STRUCTURE_ELEMENT_NAME: IDENTIFIER
STRING_TYPE_NAME: IDENTIFIER

POINTER_TO: "POINTER"i "TO"i
REFERENCE_TO: "REFERENCE"i "TO"i

DERIVED_TYPE_NAME: SINGLE_ELEMENT_TYPE_NAME
                 | ARRAY_TYPE_NAME
                 | STRUCTURE_TYPE_NAME
                 | STRING_TYPE_NAME

SINGLE_ELEMENT_TYPE_NAME: SIMPLE_TYPE_NAME
                        | SUBRANGE_TYPE_NAME
                        | ENUMERATED_TYPE_NAME

data_type_declaration: "TYPE"i _type_declaration* "END_TYPE"i ";"?

_type_declaration: array_type_declaration ";"
                 | structure_type_extends_declaration ";"?
                 | structure_type_declaration ";"?
                 | string_type_declaration ";"
                 | _single_element_type_declaration ";"

_single_element_type_declaration: simple_type_declaration
                                | extended_type_declaration
                                | subrange_type_declaration
                                | enumerated_type_declaration

simple_type_declaration: SIMPLE_TYPE_NAME ":" simple_spec_init

extended_type_declaration: SIMPLE_TYPE_NAME extends ":" simple_spec_init

simple_spec_init: [ POINTER_TO | REFERENCE_TO ] SIMPLE_SPECIFICATION [ ":=" expression ]

SIMPLE_SPECIFICATION: ELEMENTARY_TYPE_NAME
                    | SIMPLE_TYPE_NAME
                    | DOTTED_NAME

subrange_type_declaration: SUBRANGE_TYPE_NAME ":" subrange_spec_init

subrange_spec_init: [ POINTER_TO | REFERENCE_TO ] subrange_specification [ ":=" expression ]

subrange_specification: INTEGER_TYPE_NAME "(" subrange ")"
                      | SUBRANGE_TYPE_NAME

subrange: expression ".." expression
        | "*"

enumerated_type_declaration: ENUMERATED_TYPE_NAME ":" enumerated_spec_init

enumerated_spec_init: [ POINTER_TO | REFERENCE_TO ] enumerated_specification [ ":=" enumerated_value ]

enumerated_specification: "(" enumerated_value ( "," enumerated_value )* ")" [ enum_data_type_name ]
                        | ENUMERATED_TYPE_NAME

enumerated_value: [ ENUMERATED_TYPE_NAME "#" ] DOTTED_NAME [ ":=" integer_literal ]

// The following is a Beckhoff extensions of the IEC61131-3 standard
// https://infosys.beckhoff.com/english.php?content=../content/1033/tc3_plc_intro/2529504395.html
enum_data_type_name: INTEGER_TYPE_NAME
                   | BIT_STRING_TYPE_NAME

array_type_declaration: ARRAY_TYPE_NAME ":" array_spec_init

array_spec_init: [ POINTER_TO | REFERENCE_TO ] array_specification [ ":=" array_initialization ]

array_specification: "ARRAY"i "[" subrange ( "," subrange )* "]" "OF"i array_spec_type_name

array_spec_type_name: STRING_TYPE
                    | non_generic_type_name

array_initialization: "[" array_initial_elements ( "," array_initial_elements )* "]"
                    | array_initial_elements ( "," array_initial_elements )*

array_initial_elements: ( INTEGER | enumerated_value ) "(" [ array_initial_element ] ")"
                      | array_initial_element

array_initial_element: constant
                     | structure_initialization
                     | enumerated_value

structure_type_extends_declaration: STRUCTURE_TYPE_NAME extends ":" _structure_specification

structure_type_declaration: STRUCTURE_TYPE_NAME ":" _structure_specification

_structure_specification: [ POINTER_TO | REFERENCE_TO ] _structure_declaration
                        | initialized_structure

initialized_structure: STRUCTURE_TYPE_NAME ":=" structure_initialization

_structure_declaration: "STRUCT"i ( structure_element_declaration ";" )* "END_STRUCT"i ";"?

structure_element_declaration: STRUCTURE_ELEMENT_NAME [ incompl_location ] ":" ( initialized_structure | array_spec_init | STRING_VAR_TYPE | simple_spec_init | subrange_spec_init | enumerated_spec_init )

structure_initialization: "(" structure_element_initialization ( "," structure_element_initialization )* ")"

structure_element_initialization: constant
                                | STRUCTURE_ELEMENT_NAME ":=" ( constant | expression | enumerated_value | array_initialization | structure_initialization )

STRING_INITIALIZATION: ":=" STRING_LITERAL

string_type_declaration: STRING_TYPE_NAME ":" STRING_TYPE [ STRING_INITIALIZATION ]

STRING_TYPE: ( STRING | WSTRING ) [ _STRING_SPEC_LENGTH ]

STRING_VAR_TYPE: STRING_TYPE [ STRING_INITIALIZATION ]

// B.1.4
_variable: direct_variable
         | _symbolic_variable

_symbolic_variable: multi_element_variable
                  | variable_name

variable_name: IDENTIFIER [ dereferenced ]

// B.1.4.1
direct_variable: "%" location_prefix [ size_prefix ] INTEGER ( "." INTEGER )*

location_prefix: "I"
               | "Q"
               | "M"

size_prefix: "X"
           | "B"
           | "W"
           | "D"
           | "L"

// B.1.4.2
_subscript: expression

subscript_list: "[" _subscript ( "," _subscript )* "]" [ dereferenced ]

dereferenced: "^"

field_selector: [ dereferenced ] "." variable_name

multi_element_variable: variable_name ( subscript_list | field_selector ) ( subscript_list | field_selector )*

// B.1.4.3
RETAIN: "RETAIN"i
NON_RETAIN: "NON_RETAIN"i

R_EDGE: "R_EDGE"i
F_EDGE: "F_EDGE"i

FB_NAME: IDENTIFIER

input_declarations: "VAR_INPUT"i [ RETAIN | NON_RETAIN ] var_input_body "END_VAR"i ";"?

var_input_body: ( _var_input_body_item ";" )*

_var_input_body_item: var_init_decl
                    | edge_declaration

_var1_list: variable_name [ location | incompl_location ] ( "," _var1_list )*

edge_declaration: _var1_list ":" "BOOL"i ( R_EDGE | F_EDGE )

var_init_decl: array_var_init_decl
             | structured_var_init_decl
             | string_var_declaration
             | _var1_init_decl
             | fb_decl

_var1_init_decl: _var1_list ":" ( simple_spec_init | subrange_spec_init | enumerated_spec_init )

array_var_init_decl: _var1_list ":" array_spec_init

structured_var_init_decl: _var1_list ":" initialized_structure

// Function blocks
fb_decl: fb_decl_name_list ":" function_block_type_name [ ":=" structure_initialization ] -> fb_name_decl
       | fb_decl_name_list ":" fb_invocation                                              -> fb_invocation_decl

fb_decl_name_list: FB_NAME ( "," FB_NAME )*

var_body: ( var_init_decl ";" )*

output_declarations: "VAR_OUTPUT"i [ RETAIN | NON_RETAIN ] var_body "END_VAR"i ";"?

input_output_declarations: "VAR_IN_OUT"i var_body "END_VAR"i ";"?

var_declaration: _temp_var_decl
               | fb_decl

_temp_var_decl: _var1_declaration
              | array_var_declaration
              | structured_var_declaration
              | string_var_declaration

_var1_declaration: _var1_list ":" ( SIMPLE_SPECIFICATION | subrange_specification | enumerated_specification )

array_var_declaration: _var1_list ":" array_specification

structured_var_declaration: _var1_list ":" STRUCTURE_TYPE_NAME

var_declarations: "VAR"i [ CONSTANT | PERSISTENT ] var_body "END_VAR"i ";"?

retentive_var_declarations: "VAR"i RETAIN var_body "END_VAR"i ";"?

CONSTANT: "CONSTANT"i

located_var_declarations: "VAR"i [ CONSTANT | RETAIN | NON_RETAIN ] [ PERSISTENT ] located_var_decl* "END_VAR"i ";"?

located_var_decl: [ variable_name ] location ":" located_var_spec_init ";"

external_var_declarations: "VAR_EXTERNAL"i [ CONSTANT ] external_declaration* "END_VAR"i ";"?

external_declaration: GLOBAL_VAR_NAME ":" ( SIMPLE_SPECIFICATION | subrange_specification | enumerated_specification | array_specification | STRUCTURE_TYPE_NAME | function_block_type_name ) ";"

GLOBAL_VAR_NAME: IDENTIFIER
PERSISTENT: "PERSISTENT"i

global_var_declarations: "VAR_GLOBAL"i [ CONSTANT | RETAIN ] [ PERSISTENT ] _global_var_body_item* "END_VAR"i ";"?

_global_var_body_item: var_init_decl
                     | global_var_decl

global_var_decl: global_var_spec ":" ( located_var_spec_init | fb_invocation | function_block_type_name ) ";"

global_var_spec: global_var_list
               | GLOBAL_VAR_NAME (location | incompl_location) -> global_var_spec_location

located_var_spec_init: simple_spec_init
                     | subrange_spec_init
                     | enumerated_spec_init
                     | array_spec_init
                     | initialized_structure
                     | single_byte_string_spec
                     | double_byte_string_spec

location: "AT"i direct_variable

global_var_list: GLOBAL_VAR_NAME ( "," GLOBAL_VAR_NAME )*

string_var_declaration: single_byte_string_var_declaration
                      | double_byte_string_var_declaration

single_byte_string_var_declaration: _var1_list ":" single_byte_string_spec

_STRING_SPEC_LENGTH: "[" ( INTEGER | SIMPLE_TYPE_NAME ) "]"
                   | "(" ( INTEGER | SIMPLE_TYPE_NAME ) ")"

!single_byte_string_spec: "STRING"i [ _STRING_SPEC_LENGTH ] [ ":=" SINGLE_BYTE_CHARACTER_STRING ]

double_byte_string_var_declaration: _var1_list ":" double_byte_string_spec

!double_byte_string_spec: "WSTRING"i [ _STRING_SPEC_LENGTH ] [ ":=" DOUBLE_BYTE_CHARACTER_STRING ]

incompl_located_var_declarations: "VAR"i [ RETAIN | NON_RETAIN ] incompl_located_var_decl* "END_VAR"i ";"?

incompl_located_var_decl: variable_name incompl_location ":" var_spec ";"

incompl_location: "AT"i /\%(I|Q|M)\*/
STRING: "STRING"i
WSTRING: "WSTRING"i

var_spec: SIMPLE_SPECIFICATION
        | subrange_specification
        | enumerated_specification
        | array_specification
        | STRUCTURE_TYPE_NAME
        | STRING [ "[" INTEGER "]" ]
        | WSTRING [ "[" INTEGER "]" ]

// B.1.5.1
_function_name: DERIVED_FUNCTION_NAME
DERIVED_FUNCTION_NAME: IDENTIFIER

function_declaration: "FUNCTION"i DERIVED_FUNCTION_NAME ":" ( ELEMENTARY_TYPE_NAME | DERIVED_TYPE_NAME ) ";"? ( _io_var_declarations | function_var_decls )* [ function_body ] "END_FUNCTION"i ";"?

_io_var_declarations: input_declarations
                    | output_declarations
                    | input_output_declarations

function_var_decls: "VAR"i [ CONSTANT ] var_body "END_VAR"i ";"?

// TODO: {function_var_decl ';'}
function_body: statement_list
// TODO:     | ladder_diagram
// TODO:     | function_block_diagram
// TODO:     | instruction_list

function_var_decl: _var1_init_decl
                 | array_var_init_decl
                 | structured_var_init_decl
                 | string_var_declaration

// B.1.5.2
DOTTED_NAME: IDENTIFIER ( "." IDENTIFIER )*
STANDARD_FUNCTION_BLOCK_NAME: IDENTIFIER
DERIVED_FUNCTION_BLOCK_NAME: IDENTIFIER

function_block_type_name: STANDARD_FUNCTION_BLOCK_NAME
                        | DERIVED_FUNCTION_BLOCK_NAME

extends: "EXTENDS"i DOTTED_NAME

function_block_declaration: ( "FUNCTION_BLOCK"i | "FUNCTIONBLOCK"i ) DERIVED_FUNCTION_BLOCK_NAME [ extends ] fb_var_declaration* [ function_block_body ] ( "END_FUNCTION_BLOCK"i | "END_FUNCTIONBLOCK"i ) ";"?

fb_var_declaration: _io_var_declarations
                  | _other_var_declarations

_other_var_declarations: external_var_declarations
                       | var_declarations
                       | retentive_var_declarations
                       | non_retentive_var_decls
                       | temp_var_decls
                       | incompl_located_var_declarations

temp_var_decls: "VAR_TEMP"i var_body "END_VAR"i ";"?

non_retentive_var_decls: "VAR"i NON_RETAIN var_body "END_VAR"i ";"?

function_block_body: sequential_function_chart
                   | statement_list

// B.1.5.3
PROGRAM_TYPE_NAME: IDENTIFIER

program_declaration: "PROGRAM"i PROGRAM_TYPE_NAME ( _io_var_declarations | _other_var_declarations | located_var_declarations | program_access_decls )* [ function_block_body ] "END_PROGRAM"i ";"?

program_access_decls: "VAR_ACCESS"i program_access_decl ";" ( program_access_decl ";" )* "END_VAR"i ";"?

program_access_decl: ACCESS_NAME ":" _symbolic_variable ":" non_generic_type_name [ direction ]

// B.1.6
STEP_NAME: IDENTIFIER

sequential_function_chart: sfc_network+

sfc_network: initial_step ( step | transition | action | entry_action | exit_action )*

initial_step: "INITIAL_STEP"i STEP_NAME ":" ( sequential_function_chart | statement_list | action_association ) ";"? "END_STEP"i ";"?

step: "STEP"i STEP_NAME ":" [ statement_list | action_association | sequential_function_chart ] ";"? "END_STEP"i ";"?

action_association: action_name "(" [ action_qualifier ] ( "," indicator_name )* ")"

// trick to avoid collision of action_name; statements with END_block statements
action_name: /(?!END_)(\w+)/

action_qualifier: "N"
                | "R"
                | "S"
                | "P"
                | "P0"
                | "P1"
                | timed_qualifier "," action_time

timed_qualifier: "L"
               | "D"
               | "SD"
               | "DS"
               | "SL"

action_time: duration
           | variable_name

indicator_name: variable_name

transition: "TRANSITION"i [ transition_name ] [ "(" "PRIORITY"i ":=" INTEGER ")" ] "FROM"i steps "TO"i steps transition_condition "END_TRANSITION"i ";"?

transition_name: [ LOGICAL_NOT ] IDENTIFIER

steps: STEP_NAME
     | "(" STEP_NAME ( "," STEP_NAME )* ")"

transition_condition: ":=" ( expression ";"? )

action: "ACTION"i action_name ":" [ function_block_body ] "END_ACTION"i ";"?

entry_action: "ENTRY_ACTION"i [ function_block_body ] "END_ACTION"i ";"?

exit_action: "EXIT_ACTION"i [ function_block_body ] "END_ACTION"i ";"?

// B.1.7
ACCESS_NAME: IDENTIFIER
CONFIGURATION_NAME: IDENTIFIER
PROGRAM_NAME: IDENTIFIER
RESOURCE_NAME: IDENTIFIER
RESOURCE_TYPE_NAME: IDENTIFIER
TASK_NAME: IDENTIFIER

configuration_declaration: "CONFIGURATION"i CONFIGURATION_NAME [ global_var_declarations ] ( ( single_resource_declaration | ( resource_declaration resource_declaration* ) ) ) [ access_declarations ] [ instance_specific_initializations ] "END_CONFIGURATION"i ";"?

resource_declaration: "RESOURCE"i RESOURCE_NAME "ON"i RESOURCE_TYPE_NAME [ global_var_declarations ] single_resource_declaration "END_RESOURCE"i ";"?

single_resource_declaration: ( task_configuration ";" )* program_configuration ";" ( program_configuration ";" )*

access_declarations: "VAR_ACCESS"i access_declaration ";" ( access_declaration ";" )* "END_VAR"i ";"?

access_declaration: ACCESS_NAME ":" access_path ":" non_generic_type_name [ direction ]

access_path: [ RESOURCE_NAME "." ] direct_variable
           | [ RESOURCE_NAME "." ] [ PROGRAM_NAME "." ] ( FB_NAME "." )* _symbolic_variable

global_var_reference: [ RESOURCE_NAME "." ] GLOBAL_VAR_NAME [ "." STRUCTURE_ELEMENT_NAME ]

program_output_reference: PROGRAM_NAME "." _symbolic_variable

READ_WRITE: "READ_WRITE"i
READ_ONLY: "READ_ONLY"i

direction: READ_WRITE
         | READ_ONLY

task_configuration: "TASK"i TASK_NAME task_initialization

task_initialization: "(" [ "SINGLE"i ":=" data_source "," ] [ "INTERVAL"i ":=" data_source "," ] "PRIORITY"i ":=" INTEGER ")"

data_source: constant
           | global_var_reference
           | program_output_reference
           | direct_variable

program_configuration: "PROGRAM"i [ RETAIN | NON_RETAIN ] PROGRAM_NAME [ "WITH"i TASK_NAME ] ":" PROGRAM_TYPE_NAME [ "(" prog_conf_elements ")" ]

prog_conf_elements: prog_conf_element ( "," prog_conf_element )*

prog_conf_element: fb_task
                 | prog_cnxn

fb_task: FB_NAME "WITH"i TASK_NAME

prog_cnxn: _symbolic_variable ":=" prog_data_source
         | _symbolic_variable "=>" data_sink

prog_data_source: constant
                | enumerated_value
                | global_var_reference
                | direct_variable

data_sink: global_var_reference
         | direct_variable

instance_specific_initializations: "VAR_CONFIG"i ( instance_specific_init ";" )* "END_VAR"i ";"?

instance_specific_init: RESOURCE_NAME "." PROGRAM_NAME "." ( FB_NAME "." )* ( ( variable_name [ location ] ":" located_var_spec_init ) | ( FB_NAME ":" function_block_type_name ":=" structure_initialization ) )

// B.2.1, B.3.1
LOGICAL_OR: "OR"i
LOGICAL_XOR: "XOR"i
LOGICAL_AND: "AND"i
LOGICAL_NOT: "NOT"i
MODULO: "MOD"i
EQUALS: "="
EQUALS_NOT: "<>"
LESS_OR_EQUAL: "<="
GREATER_OR_EQUAL: ">="
LESS_THAN: "<"
GREATER_THAN: ">"
ADDING: "+"
SUBTRACTING: "-"
MULTIPLY_WITH: "*"
DIVIDE_BY: "/"
ELEVATED_BY: "**"
MINUS: "-"
PLUS: "+"

expression: _xor_expression ( LOGICAL_OR _xor_expression )*

_xor_expression: _and_expression ( LOGICAL_XOR _and_expression )*

_and_expression: _comparison ( LOGICAL_AND _comparison )*

_comparison: _equ_expression ( ( EQUALS | EQUALS_NOT ) _equ_expression )*

_equ_expression: _add_expression ( ( LESS_OR_EQUAL | GREATER_OR_EQUAL | LESS_THAN | GREATER_THAN ) _add_expression )*

_add_expression: _term ( _add_operator _term )*

_add_operator: ADDING
             | SUBTRACTING

_term: _power_expression ( _multiply_operator _power_expression )*

_multiply_operator: MODULO
                  | MULTIPLY_WITH
                  | DIVIDE_BY

_power_expression: _unary_expression ( ELEVATED_BY _unary_expression )*

_unary_expression: constant
                 | [ _unary_operator ] _primary_expression

_unary_operator: LOGICAL_NOT
               | MINUS
               | PLUS

function_call: ( _function_name | multi_element_variable ) "(" [ param_assignment ( "," param_assignment )* ","? ] ")"

// see also: fb_invocation
_primary_expression: "(" expression ")"
                   | function_call
                   | _variable
                   | multi_element_variable

// B.3.2
statement_list: _statement+

_statement: ";"+
          | method
          | assignment_statement
          | no_op_statement
          | set_statement
          | reset_statement
          | reference_assignment_statement
          | _subprogram_control_statement
          | _selection_statement
          | _iteration_statement
          | action_name ";"

// B.3.2.1
no_op_statement: _variable ";"

assignment_statement: _variable ":=" ( _variable ":=" )* expression ";"

set_statement: _variable "S="i expression ";"

reset_statement: _variable "R="i expression ";"

reference_assignment_statement: _variable "REF="i expression ";"

// method ::= expression [dereferenced] '.' _identifier '(' ')';
method: expression "(" ")" ";"

// B.3.2.2
return_statement: "RETURN"i ";"?

_subprogram_control_statement: return_statement
                             | fb_invocation ";"

fb_invocation: fb_invocation_name "(" [ param_assignment ( "," param_assignment )* ","? ] ")"

fb_invocation_name: FB_NAME
                  | multi_element_variable

param_assignment: [ LOGICAL_NOT ] variable_name "=>" [ expression | multi_element_variable ]
                | variable_name ":=" [ expression | multi_element_variable ]
                | expression
                | multi_element_variable

// B.3.2.3
_selection_statement: if_statement
                    | case_statement

if_statement: "IF"i expression "THEN"i [ statement_list ] ( "ELSIF"i expression "THEN"i [ statement_list ] )* [ "ELSE"i [ statement_list ] ] "END_IF"i ";"?

case_statement: "CASE"i expression "OF"i case_element case_element* [ "ELSE"i [ statement_list ] ] "END_CASE"i ";"?

case_element: case_list ":" [ statement_list ]

case_list: case_list_element ( "," case_list_element )*

case_list_element: subrange
                 | integer_literal
                 | enumerated_value
                 | DOTTED_NAME

// B.3.2.4
CONTROL_VARIABLE: IDENTIFIER

_iteration_statement: for_statement
                    | while_statement
                    | repeat_statement
                    | exit_statement

for_statement: "FOR"i CONTROL_VARIABLE ":=" for_list "DO"i statement_list "END_FOR"i ";"?

for_list: expression "TO"i expression [ "BY"i expression ]

while_statement: "WHILE"i expression "DO"i statement_list "END_WHILE"i ";"?

repeat_statement: "REPEAT"i statement_list "UNTIL"i expression "END_REPEAT"i ";"?

exit_statement: "EXIT"i ";"?
